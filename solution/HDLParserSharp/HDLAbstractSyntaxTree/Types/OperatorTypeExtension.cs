using System;
using System.Collections.Generic;
using System.Text;

namespace HDLAbstractSyntaxTree.Types
{
    public static class OperatorTypeExtension
    {
        public static OperatorType ToUnary(this OperatorType type)
            => type switch
            { 
                OperatorType.Sub => OperatorType.MinusUnary,
                OperatorType.Add => OperatorType.PlusUnary,
                OperatorType.Or => OperatorType.OrUnary,
                OperatorType.And => OperatorType.AndUnary,
                OperatorType.Nand => OperatorType.NandUnary,
                OperatorType.Nor => OperatorType.NorUnary,
                OperatorType.Xor => OperatorType.XorUnary,
                OperatorType.Xnor => OperatorType.XnorUnary,
                _ => throw new NotImplementedException("Invalid operator type")
            };

        public static string GetOperatorString(this OperatorType type)
            => type switch
            {
                OperatorType.MinusUnary => "-(X)",
                OperatorType.PlusUnary => "+(X)",
                OperatorType.Sub => "(X) - (Y)",
                OperatorType.Add => "(X) + (Y)",
                OperatorType.Div => "(X) / (Y)",
                OperatorType.Mul => "(X) * (Y)",
                OperatorType.Mod => "(X) % (Y)",
                OperatorType.Rem => "(X) rem (Y)",
                OperatorType.Pow => "(X) ** (Y)",
                OperatorType.Abs => "|(X)|",
                OperatorType.IncrPre => "++(X)",
                OperatorType.DecrPre => "--(X)",
                OperatorType.IncrPost => "(X)++",
                OperatorType.DecrPost => "(X)--",
                OperatorType.NegLog => "!(X)",
                OperatorType.Neg => "~(X)",
                OperatorType.AndLog => "(X) && (Y)",
                OperatorType.OrLog => "(X) || (Y)",
                OperatorType.And => "(X) & (Y)",
                OperatorType.Or => "(X) | (Y)",
                OperatorType.Nand => "~((X) & (Y))",
                OperatorType.Nor => "~((X) | (Y))",
                OperatorType.Xor => "(X) ^ (Y)",
                OperatorType.Xnor => "~((X) ^ (Y))",
                OperatorType.OrUnary => "|(X)",
                OperatorType.AndUnary => "&(X)",
                OperatorType.NandUnary => "~&(X)",
                OperatorType.NorUnary => "~|(X)",
                OperatorType.XorUnary => "^(X)",
                OperatorType.XnorUnary => "~^(X)",
                OperatorType.Sll => "(X) << (Y)",
                OperatorType.Srl => "(X) >> (Y)",
                OperatorType.Sla => "(X) <<< (Y)",
                OperatorType.Sra => "(X) >>> (Y)",
                OperatorType.Rol => "(X) rol (Y)",
                OperatorType.Ror => "(X) ror (Y)",
                OperatorType.Eq => "(X) == (Y)",
                OperatorType.Ne => "(X) != (Y)",
                OperatorType.Is => "(X) === (Y)",
                OperatorType.IsNot => "(X) !== (Y)",
                OperatorType.Lt => "(X) < (Y)",
                OperatorType.Le => "(X) <= (Y)",
                OperatorType.Gt => "(X) > (Y)",
                OperatorType.Ge => "(X) >= (Y)",
                OperatorType.EqMatch => "(X) ==? (Y)",
                OperatorType.NeMatch => "(X) !=? (Y)",
                OperatorType.LtMatch => "(X) <? (Y)",
                OperatorType.LeMatch => "(X) <=? (Y)",
                OperatorType.GtMatch => "(X) >? (Y)",
                OperatorType.GeMatch => "(X) >=? (Y)",
                OperatorType.Index => "(X)[(Y)]",
                OperatorType.Concat => "{(X), (Y)}",
                OperatorType.ReplConcat => "{(X){(Y)}}",
                OperatorType.PartSelectPost => "[(X)+:(Y)]",
                OperatorType.PartSelectPre => "[(X)-:(Y)]",
                OperatorType.Dot => "(X).(Y)",
                OperatorType.DoubleColon => "(X)::(Y)",
                OperatorType.Apostrophe => "*(X)",
                OperatorType.Arrow => "(X)->(Y)",
                OperatorType.Reference => "ref (X)",
                OperatorType.Dereference => "deref (X)",
                OperatorType.Assign => "(X) = (Y)",
                OperatorType.PlusAssign => "(X) += (Y)",
                OperatorType.MinusAssign => "(X) -= (Y)",
                OperatorType.MulAssign => "(X) *= (Y)",
                OperatorType.DivAssign => "(X) /= (Y)",
                OperatorType.ModAssign => "(X) %= (Y)",
                OperatorType.AndAssign => "(X) &= (Y)",
                OperatorType.OrAssign => "(X) |= (Y)",
                OperatorType.XorAssign => "(X) ^= (Y)",
                OperatorType.ShiftLeftAssign => "(X) <<= (Y)",
                OperatorType.ShiftRightAssign => "(X) >>= (Y)",
                OperatorType.ArithShiftLeftAssign => "(X) <<<= (Y)",
                OperatorType.ArithShiftRightAssign => "(X) >>>= (Y)",
                OperatorType.Ternary => "(X) ? (Y) : Z",
                OperatorType.Call => "(X)(args)",
                OperatorType.Rising => "posedge (X)",
                OperatorType.Falling => "negedge (X)",
                OperatorType.Downto => "[(X):(Y)]",
                OperatorType.To => "[(Y):(X)]",
                OperatorType.Parametrization => "param <X>",
                OperatorType.MapAssociation => "(X) <= (Y)",
                OperatorType.Range => "[(X)..(Y)]",
                OperatorType.Throughout => "(X) throughout (Y)",
                OperatorType.DefineResolver => "define (X)",
                OperatorType.TypeOf => "typeof(X)",
                OperatorType.UnitSpec => "(X) unit",
                OperatorType.MultiDimension => "[X, Y, ...]",
                _ => throw new Exception("Invalid operator")
            };
    }
}
